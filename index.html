<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Builder - Group Workspace</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <!-- QR Code Generator Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e27;
            color: #fff;
        }

        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #groupTitle {
            font-size: 24px;
            font-weight: bold;
        }

        #scene-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        a-scene {
            width: 100%;
            height: 100%;
        }

        #ui-panel {
            background: rgba(15, 23, 42, 0.95);
            padding: 15px;
            border-top: 2px solid #667eea;
            max-height: 180px;
            overflow-y: auto;
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.3);
        }

        #controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #3b4565;
        }

        .btn-secondary:hover {
            background: #4a5580;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        #asset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .asset-btn {
            background: #3b4565;
            padding: 8px 12px;
            font-size: 13px;
        }

        .asset-btn:hover {
            background: #4a5580;
        }

        #info {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.4;
        }

        #info strong {
            color: #fbbf24;
        }

        #info kbd {
            background: linear-gradient(180deg, #4a5580 0%, #3b4565 100%);
            border: 1px solid #667eea;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            font-family: monospace;
            box-shadow: 0 2px 0 #2a3350;
        }

        #camera-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10;
        }

        @media (max-width: 768px) {
            #groupTitle {
                font-size: 18px;
            }

            button {
                padding: 8px 12px;
                font-size: 12px;
            }

            #ui-panel {
                max-height: 200px;
            }
        }

        /* Edit Mode Toggle Button */
        .btn-edit-mode {
            background: #3b4565;
            position: relative;
        }

        .btn-edit-mode.active {
            background: #f39c12;
            animation: pulse-glow 1.5s infinite;
        }

        .btn-edit-mode.active:hover {
            background: #e67e22;
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 5px rgba(243, 156, 18, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(243, 156, 18, 0.8);
            }
        }

        /* Mode Indicator */
        #mode-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
        }

        #mode-indicator.view-mode {
            border: 2px solid #3498db;
        }

        #mode-indicator.edit-mode {
            border: 2px solid #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }

        #mode-indicator .mode-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #3498db;
        }

        #mode-indicator.edit-mode .mode-dot {
            background: #f39c12;
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* Selected Object Controls */
        #selected-object-controls {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            align-items: center;
            gap: 15px;
            z-index: 20;
            border: 2px solid #f39c12;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        #selected-object-controls.visible {
            display: flex;
        }

        #selected-object-controls .object-info {
            font-size: 13px;
            color: #fbbf24;
        }

        #delete-selected-btn {
            background: #e74c3c;
            padding: 8px 15px;
            font-size: 13px;
        }

        #delete-selected-btn:hover {
            background: #c0392b;
        }

        /* QR Code Modal */
        #qr-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        #qr-modal.visible {
            display: flex;
        }

        .qr-modal-content {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(102, 126, 234, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .qr-modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .qr-modal-subtitle {
            color: #94a3b8;
            font-size: 14px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        #qr-code-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            display: inline-block;
            margin-bottom: 20px;
        }

        #qr-code-container canvas,
        #qr-code-container img {
            display: block;
        }

        .qr-instructions {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .qr-instructions h4 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .qr-instructions ol {
            color: #e2e8f0;
            font-size: 13px;
            text-align: left;
            padding-left: 20px;
            line-height: 1.8;
        }

        .qr-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .qr-modal-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.3s;
        }

        .qr-modal-btn.primary {
            background: #667eea;
            color: white;
        }

        .qr-modal-btn.primary:hover {
            background: #764ba2;
        }

        .qr-modal-btn.secondary {
            background: #3b4565;
            color: white;
        }

        .qr-modal-btn.secondary:hover {
            background: #4a5580;
        }

        .qr-url-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            word-break: break-all;
            font-size: 11px;
            color: #94a3b8;
            max-height: 60px;
            overflow-y: auto;
        }

        .hosting-note {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 12px;
            color: #fbbf24;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="header">
            <div id="groupTitle">Group Workspace</div>
            <div style="display: flex; gap: 10px;">
                <button id="saveBtn" class="btn-success" title="Save to this browser">üíæ Save to Browser</button>
                <button id="exportBtn" class="btn-secondary" title="Copy shareable link">üîó Share Link</button>
                <button id="clearBtn" class="btn-danger" title="Delete all objects">üóëÔ∏è Clear All</button>
            </div>
        </div>

        <div id="scene-container">
            <a-scene embedded vr-mode-ui="enabled: false" webxr="requiredFeatures: hit-test,local-floor;">
                <a-camera position="0 1.6 3" rotation="0 0 0" wasd-controls look-controls></a-camera>
                <a-light type="ambient" intensity="1.0" color="#ffffff"></a-light>
                <a-light type="directional" intensity="0.8" position="5 10 7" color="#ffffff"></a-light>
                <a-light type="point" intensity="0.5" position="0 3 0" color="#ffffff"></a-light>
                <a-plane position="0 0 -4" rotation="-90 0 0" width="20" height="20" color="#4a5580"
                    opacity="0.3"></a-plane>
                <a-entity id="objects-container"></a-entity>
            </a-scene>
            <div id="camera-info">üì± Drag to move horizontally | <strong>Shift+Drag</strong> to move up/down | Scroll to
                rotate view</div>

            <!-- Mode Indicator -->
            <div id="mode-indicator" class="view-mode">
                <span class="mode-dot"></span>
                <span id="mode-text">View Mode</span>
            </div>

            <!-- Selected Object Controls -->
            <div id="selected-object-controls">
                <span class="object-info">üì¶ <span id="selected-object-type">Object</span> selected</span>
                <button id="delete-selected-btn" class="btn-danger">üóëÔ∏è Delete</button>
            </div>
        </div>

        <div id="ui-panel">
            <div id="controls">
                <div>
                    <strong style="font-size: 13px;">Add Objects:</strong>
                </div>
                <div id="asset-buttons">
                    <button class="asset-btn" onclick="addObject('box', '#e74c3c')">üì¶ Box</button>
                    <button class="asset-btn" onclick="addObject('sphere', '#3498db')">‚ö™ Sphere</button>
                    <button class="asset-btn" onclick="addObject('cylinder', '#f39c12')">üî∂ Cylinder</button>
                    <button class="asset-btn" onclick="addObject('cone', '#9b59b6')">üî∫ Cone</button>
                    <button class="asset-btn" onclick="addObject('plane', '#1abc9c')">üìÑ Plane</button>
                    <button class="asset-btn" onclick="addObject('dodecahedron', '#e67e22')">üî∑ Dodeca</button>
                </div>
            </div>
            <button id="editModeBtn" class="btn-edit-mode">‚úèÔ∏è Edit Mode</button>
            <button id="arBtn" class="btn-success">üì± AR QR Code</button>
            <button class="btn-secondary" onclick="downloadScene()">‚¨áÔ∏è Download Scene Data</button>
            <div id="info">
                <strong>Group:</strong> <span id="groupNum">1</span> |
                <strong>Objects:</strong> <span id="objectCount">0</span> |
                <strong>Shortcuts:</strong> <kbd>E</kbd> Edit Mode | <kbd>Shift+Drag</kbd> Up/Down | <kbd>Del</kbd>
                Delete | <kbd>Esc</kbd> Exit<br>
                <small id="ar-info" style="color: #fbbf24;">ÔøΩ Save = keep your work | üîó Share = get a link | üì± AR QR
                    Code = view on phone</small>
            </div>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qr-modal">
        <div class="qr-modal-content">
            <div class="qr-modal-title">
                üì± View in AR
            </div>
            <div class="qr-modal-subtitle">
                Scan this QR code with your phone to view your scene in augmented reality
            </div>

            <div id="qr-code-container">
                <!-- QR code will be generated here -->
            </div>

            <div class="qr-instructions">
                <h4>üìã Instructions for Students:</h4>
                <ol>
                    <li>Open your phone's camera app</li>
                    <li>Point it at the QR code above</li>
                    <li>Tap the notification that appears</li>
                    <li>Allow camera access when prompted</li>
                    <li>Point your phone at a flat surface to see your objects!</li>
                </ol>
            </div>

            <div class="qr-url-display" id="ar-url-display">
                Loading AR URL...
            </div>

            <div class="qr-modal-buttons">
                <button class="qr-modal-btn secondary" onclick="copyARUrl()">üìã Copy Link</button>
                <button class="qr-modal-btn primary" onclick="closeQRModal()">‚úï Close</button>
            </div>

            <div class="hosting-note" id="hosting-note" style="display: none;">
                ‚ö†Ô∏è <strong>Note:</strong> For QR codes to work, this page must be hosted on a web server (not opened as
                a local file).
                Use GitHub Pages, Netlify, or any web hosting service.
            </div>
        </div>
    </div>

    <script>
        const scene = document.querySelector('a-scene');
        const objectsContainer = document.getElementById('objects-container');
        let objects = [];
        let selectedObject = null;
        let isDragging = false;
        let dragPlane, verticalDragPlane, raycaster, mouse, intersectPoint;
        let sceneReady = false;
        let isShiftHeld = false;
        let lastMouseY = 0;
        let cameraEl = null;
        let isEditMode = false;
        let persistentSelectedObject = null; // For tracking selection outside of drag

        // Helper function to convert mouse coordinates relative to the A-Frame canvas
        function getMouseNDC(event) {
            const canvas = document.querySelector('.a-canvas');
            if (!canvas) {
                // Fallback to window coordinates
                return {
                    x: (event.clientX / window.innerWidth) * 2 - 1,
                    y: -(event.clientY / window.innerHeight) * 2 + 1
                };
            }

            const rect = canvas.getBoundingClientRect();
            return {
                x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
                y: -((event.clientY - rect.top) / rect.height) * 2 + 1
            };
        }

        // Helper function to enable/disable camera controls
        function setCameraControlsEnabled(enabled) {
            if (!cameraEl) return;
            if (enabled) {
                cameraEl.setAttribute('look-controls', 'enabled', true);
                cameraEl.setAttribute('wasd-controls', 'enabled', true);
            } else {
                cameraEl.setAttribute('look-controls', 'enabled', false);
                cameraEl.setAttribute('wasd-controls', 'enabled', false);
            }
        }

        // Helper function to add/remove glow effect on objects
        function setObjectGlow(entity, glowing) {
            if (!entity) return;
            const color = entity.getAttribute('data-color') || '#ffffff';
            if (glowing) {
                entity.setAttribute('material', {
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4
                });
            } else {
                entity.setAttribute('material', {
                    color: color,
                    emissive: '#000000',
                    emissiveIntensity: 0
                });
            }
        }

        // Helper function to update mode indicator UI
        function updateModeIndicator() {
            const indicator = document.getElementById('mode-indicator');
            const modeText = document.getElementById('mode-text');
            const editModeBtn = document.getElementById('editModeBtn');

            if (isEditMode) {
                indicator.className = 'edit-mode';
                modeText.textContent = 'Edit Mode';
                editModeBtn.classList.add('active');
                editModeBtn.textContent = '‚úîÔ∏è Editing';
            } else {
                indicator.className = 'view-mode';
                modeText.textContent = 'View Mode';
                editModeBtn.classList.remove('active');
                editModeBtn.textContent = '‚úèÔ∏è Edit Mode';
            }
        }

        // Helper function to show/hide selected object controls
        function updateSelectionUI(obj) {
            const controls = document.getElementById('selected-object-controls');
            const typeSpan = document.getElementById('selected-object-type');

            if (obj && isEditMode) {
                const objType = obj.getAttribute('data-type') || 'Object';
                typeSpan.textContent = objType.charAt(0).toUpperCase() + objType.slice(1);
                controls.classList.add('visible');
            } else {
                controls.classList.remove('visible');
            }
        }

        // Function to delete the currently selected object
        function deleteSelectedObject() {
            if (!persistentSelectedObject) return;

            const objId = persistentSelectedObject.id;

            // Remove glow
            setObjectGlow(persistentSelectedObject, false);

            // Remove from DOM
            persistentSelectedObject.remove();

            // Remove from objects array
            objects = objects.filter(o => o.id !== objId);

            // Clear selection
            persistentSelectedObject = null;
            selectedObject = null;
            updateSelectionUI(null);
            updateObjectCount();

            console.log(`Deleted object: ${objId}`);
        }

        // Toggle edit mode
        function toggleEditMode() {
            isEditMode = !isEditMode;
            updateModeIndicator();

            // If exiting edit mode, clear selection
            if (!isEditMode && persistentSelectedObject) {
                setObjectGlow(persistentSelectedObject, false);
                persistentSelectedObject.setAttribute('scale', '1.2 1.2 1.2');
                persistentSelectedObject = null;
                updateSelectionUI(null);
            }

            // Update camera controls based on mode
            setCameraControlsEnabled(!isEditMode);
        }

        const params = new URLSearchParams(window.location.search);
        const groupId = params.get('group') || '1';
        document.getElementById('groupNum').textContent = groupId;
        document.getElementById('groupTitle').textContent = `Group ${groupId} - AR Builder`;

        function addObject(type, color) {
            const id = `obj-${Date.now()}`;
            const entity = document.createElement('a-entity');
            entity.id = id;
            entity.setAttribute('class', 'draggable-object');

            const position = {
                x: Math.random() * 4 - 2,
                y: 1.5 + Math.random() * 1.5,
                z: -2 - Math.random() * 3
            };

            entity.setAttribute('position', position);
            entity.setAttribute('geometry', {
                primitive: type,
                radius: type === 'sphere' ? 0.5 : undefined,
                height: type === 'cylinder' || type === 'cone' ? 1 : undefined,
                radiusBottom: type === 'cone' ? 0.5 : undefined,
                radiusTop: type === 'cone' ? 0.1 : undefined
            });
            entity.setAttribute('material', { color: color });
            entity.setAttribute('scale', '1.2 1.2 1.2');
            entity.setAttribute('data-type', type);
            entity.setAttribute('data-color', color);

            objectsContainer.appendChild(entity);
            objects.push({ id, type, color, element: entity });
            updateObjectCount();

            console.log(`Added ${type} at position:`, position, 'Camera should see it!');
        }

        document.addEventListener('click', (event) => {
            if (!sceneReady) return;
            if (event.target.tagName === 'BUTTON' || event.target.closest('button')) return;

            // Only allow object interaction in Edit Mode
            if (!isEditMode) return;

            const camera = scene.camera;
            if (!camera) return;

            const ndc = getMouseNDC(event);
            mouse.x = ndc.x;
            mouse.y = ndc.y;

            raycaster.setFromCamera(mouse, camera);

            const draggables = objectsContainer.querySelectorAll('.draggable-object');
            const intersects = raycaster.intersectObjects(
                Array.from(draggables).map(d => d.object3D.children[0] || d.object3D),
                true
            );

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object.el || intersects[0].object.parent.el;

                // If clicking a different object, deselect the previous one
                if (persistentSelectedObject && persistentSelectedObject !== clickedObject) {
                    setObjectGlow(persistentSelectedObject, false);
                    persistentSelectedObject.setAttribute('scale', '1.2 1.2 1.2');
                }

                // Select the new object
                selectedObject = clickedObject;
                persistentSelectedObject = clickedObject;
                isDragging = true;
                lastMouseY = event.clientY;

                // Apply visual feedback
                selectedObject.setAttribute('scale', '1.3 1.3 1.3');
                setObjectGlow(selectedObject, true);
                updateSelectionUI(selectedObject);

                // Disable camera controls while dragging
                setCameraControlsEnabled(false);
            } else {
                // Clicked on empty space - deselect current object
                if (persistentSelectedObject) {
                    setObjectGlow(persistentSelectedObject, false);
                    persistentSelectedObject.setAttribute('scale', '1.2 1.2 1.2');
                    persistentSelectedObject = null;
                    updateSelectionUI(null);
                }
                selectedObject = null;
            }
        });

        // Track Shift key state and keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') {
                isShiftHeld = true;
            }

            // Delete key to remove selected object
            if ((event.key === 'Delete' || event.key === 'Backspace') && persistentSelectedObject && isEditMode) {
                event.preventDefault();
                deleteSelectedObject();
            }

            // Escape to exit edit mode
            if (event.key === 'Escape' && isEditMode) {
                toggleEditMode();
            }

            // E key to toggle edit mode
            if (event.key === 'e' || event.key === 'E') {
                // Don't toggle if typing in an input
                if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
                    toggleEditMode();
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                isShiftHeld = false;
            }
        });

        document.addEventListener('mousemove', (event) => {
            if (!sceneReady || !isDragging || !selectedObject) return;

            const camera = scene.camera;
            if (!camera) return;

            const ndc = getMouseNDC(event);
            mouse.x = ndc.x;
            mouse.y = ndc.y;

            const pos = selectedObject.getAttribute('position');

            if (isShiftHeld) {
                // Vertical movement (Y-axis) based on mouse Y delta
                const deltaY = (lastMouseY - event.clientY) * 0.01;
                const newY = Math.max(0.1, pos.y + deltaY); // Keep above ground
                selectedObject.setAttribute('position', {
                    x: pos.x,
                    y: newY,
                    z: pos.z
                });
            } else {
                // Horizontal movement (X and Z axes)
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);

                selectedObject.setAttribute('position', {
                    x: intersectPoint.x,
                    y: pos.y,
                    z: intersectPoint.z
                });
            }

            lastMouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            if (selectedObject && persistentSelectedObject === selectedObject) {
                // Keep the selected scale (slightly larger) but not the drag scale
                selectedObject.setAttribute('scale', '1.25 1.25 1.25');
            }
            isDragging = false;
            selectedObject = null;

            // Re-enable camera controls after dragging (but stay in edit mode)
            if (isEditMode) {
                setCameraControlsEnabled(false); // Keep camera locked in edit mode
            } else {
                setCameraControlsEnabled(true);
            }
        });

        document.addEventListener('touchstart', (event) => {
            const touch = event.touches[0];
            const clickEvent = new MouseEvent('click', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            document.dispatchEvent(clickEvent);

            // Disable camera controls on touch drag
            if (isDragging) {
                setCameraControlsEnabled(false);
            }
        });

        document.addEventListener('touchmove', (event) => {
            if (!isDragging || !selectedObject) return;
            const touch = event.touches[0];
            const moveEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            document.dispatchEvent(moveEvent);
        });

        document.addEventListener('touchend', (event) => {
            const endEvent = new MouseEvent('mouseup', {});
            document.dispatchEvent(endEvent);
        });

        function updateObjectCount() {
            document.getElementById('objectCount').textContent = objects.length;
        }

        // LocalStorage Save/Load Functions
        function getStorageKey() {
            return `ar-builder-scene-group-${groupId}`;
        }

        function getSceneData() {
            return objects.map(obj => {
                const pos = obj.element.getAttribute('position');
                const scale = obj.element.getAttribute('scale');
                return {
                    type: obj.type,
                    color: obj.color,
                    position: pos,
                    scale: scale
                };
            });
        }

        function saveToLocalStorage() {
            const sceneData = getSceneData();
            const storageKey = getStorageKey();

            try {
                localStorage.setItem(storageKey, JSON.stringify(sceneData));
                const timestamp = new Date().toLocaleTimeString();
                alert(`‚úÖ Scene saved!\n\nYour ${objects.length} object(s) are saved to this browser.\nSaved at: ${timestamp}\n\nYour work will be here when you come back.`);
                console.log('Scene saved to localStorage:', storageKey);
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
                alert('‚ùå Could not save. Your browser may be in private mode or storage is full.');
            }
        }

        function loadFromLocalStorage() {
            const storageKey = getStorageKey();

            try {
                const savedData = localStorage.getItem(storageKey);
                if (savedData) {
                    const sceneData = JSON.parse(savedData);
                    console.log('Found saved scene with', sceneData.length, 'objects');
                    return sceneData;
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }
            return null;
        }

        function restoreSavedScene() {
            const savedScene = loadFromLocalStorage();
            if (savedScene && savedScene.length > 0) {
                // Ask user if they want to restore
                if (confirm(`Found a saved scene with ${savedScene.length} object(s). Would you like to restore it?`)) {
                    savedScene.forEach(obj => {
                        addObject(obj.type, obj.color, obj.position);
                    });
                    console.log('Restored', savedScene.length, 'objects from localStorage');
                }
            }
        }

        // Save button event listener
        document.getElementById('saveBtn').addEventListener('click', () => {
            if (objects.length === 0) {
                alert('Nothing to save! Add some objects first.');
                return;
            }
            saveToLocalStorage();
        });

        // QR Code Modal Functions
        let currentARUrl = '';
        let qrCodeInstance = null;

        function generateARUrl() {
            // Get current scene data
            const sceneData = objects.map(obj => {
                const pos = obj.element.getAttribute('position');
                const scale = obj.element.getAttribute('scale');
                return {
                    type: obj.type,
                    color: obj.color,
                    position: pos,
                    scale: scale
                };
            });

            // Encode scene data
            const encoded = btoa(JSON.stringify(sceneData));

            // Build the AR viewer URL - handle both local and GitHub Pages URLs
            let baseUrl = window.location.href.split('?')[0];

            // Remove trailing slash if present
            if (baseUrl.endsWith('/')) {
                baseUrl = baseUrl.slice(0, -1);
            }

            // Remove index.html if present
            if (baseUrl.endsWith('index.html')) {
                baseUrl = baseUrl.replace('index.html', '');
            }

            // Ensure baseUrl ends with /
            if (!baseUrl.endsWith('/')) {
                baseUrl += '/';
            }

            const arViewerUrl = baseUrl + 'ar-viewer.html';
            console.log('AR Viewer URL:', arViewerUrl);

            return `${arViewerUrl}?group=${groupId}&scene=${encoded}`;
        }

        function showQRModal() {
            if (objects.length === 0) {
                alert('Please add at least one object to your scene before viewing in AR.');
                return;
            }

            const modal = document.getElementById('qr-modal');
            const qrContainer = document.getElementById('qr-code-container');
            const urlDisplay = document.getElementById('ar-url-display');
            const hostingNote = document.getElementById('hosting-note');

            // Generate AR URL
            currentARUrl = generateARUrl();
            urlDisplay.textContent = currentARUrl;

            // Check if running from file:// protocol
            if (window.location.protocol === 'file:') {
                hostingNote.style.display = 'block';
            } else {
                hostingNote.style.display = 'none';
            }

            // Clear previous QR code
            qrContainer.innerHTML = '';

            // Generate new QR code
            try {
                qrCodeInstance = new QRCode(qrContainer, {
                    text: currentARUrl,
                    width: 200,
                    height: 200,
                    colorDark: '#000000',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.M
                });
            } catch (e) {
                console.error('Failed to generate QR code:', e);
                qrContainer.innerHTML = '<div style="color: #e74c3c; padding: 20px;">Failed to generate QR code</div>';
            }

            // Show modal
            modal.classList.add('visible');
        }

        function closeQRModal() {
            const modal = document.getElementById('qr-modal');
            modal.classList.remove('visible');
        }

        function copyARUrl() {
            if (!currentARUrl) return;

            navigator.clipboard.writeText(currentARUrl).then(() => {
                alert('AR link copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = currentARUrl;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('AR link copied to clipboard!');
            });
        }

        // Close modal when clicking outside
        document.getElementById('qr-modal').addEventListener('click', (e) => {
            if (e.target.id === 'qr-modal') {
                closeQRModal();
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('Clear all objects? This cannot be undone.')) {
                // Clear any selection first
                if (persistentSelectedObject) {
                    setObjectGlow(persistentSelectedObject, false);
                    persistentSelectedObject = null;
                    updateSelectionUI(null);
                }
                objectsContainer.innerHTML = '';
                objects = [];
                updateObjectCount();
            }
        });

        // Edit Mode toggle button
        document.getElementById('editModeBtn').addEventListener('click', toggleEditMode);

        // Delete selected object button
        document.getElementById('delete-selected-btn').addEventListener('click', deleteSelectedObject);

        document.getElementById('exportBtn').addEventListener('click', () => {
            if (objects.length === 0) {
                alert('Nothing to share! Add some objects first.');
                return;
            }

            const sceneData = getSceneData();
            const encoded = btoa(JSON.stringify(sceneData));
            const shareUrl = `${window.location.href.split('?')[0]}?group=${groupId}&scene=${encoded}`;

            navigator.clipboard.writeText(shareUrl).then(() => {
                alert(`üîó Link copied!\n\nAnyone with this link can view your scene.\nShare it via email, chat, or paste in a document.`);
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = shareUrl;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`üîó Link copied!\n\nAnyone with this link can view your scene.`);
            });
        });

        function downloadScene() {
            const sceneData = objects.map(obj => {
                const pos = obj.element.getAttribute('position');
                const scale = obj.element.getAttribute('scale');
                return {
                    type: obj.type,
                    color: obj.color,
                    position: pos,
                    scale: scale
                };
            });

            const dataStr = JSON.stringify(sceneData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `group-${groupId}-scene.json`;
            link.click();
        }

        function loadSceneFromUrl() {
            const sceneParam = params.get('scene');
            if (sceneParam) {
                try {
                    const sceneData = JSON.parse(atob(sceneParam));
                    sceneData.forEach(obj => {
                        const id = `obj-${Date.now()}-${Math.random()}`;
                        const entity = document.createElement('a-entity');
                        entity.id = id;
                        entity.setAttribute('class', 'draggable-object');
                        entity.setAttribute('position', obj.position);
                        entity.setAttribute('geometry', {
                            primitive: obj.type,
                            radius: obj.type === 'sphere' ? 0.5 : undefined,
                            height: obj.type === 'cylinder' || obj.type === 'cone' ? 1 : undefined,
                            radiusBottom: obj.type === 'cone' ? 0.5 : undefined,
                            radiusTop: obj.type === 'cone' ? 0.1 : undefined
                        });
                        entity.setAttribute('material', { color: obj.color });
                        entity.setAttribute('scale', obj.scale);
                        entity.setAttribute('data-type', obj.type);
                        entity.setAttribute('data-color', obj.color);
                        objectsContainer.appendChild(entity);
                        objects.push({ id, type: obj.type, color: obj.color, element: entity });
                    });
                    updateObjectCount();
                } catch (e) {
                    console.error('Failed to load scene:', e);
                }
            }
        }

        // AR Button - Show QR Code Modal
        document.getElementById('arBtn').addEventListener('click', () => {
            showQRModal();
        });

        scene.addEventListener('loaded', () => {
            // Wait for THREE.js to be available
            if (typeof THREE === 'undefined') {
                console.error('THREE.js is not available');
                return;
            }

            // Initialize THREE.js objects after scene is loaded
            dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            dragPlane.setFromNormalAndCoplanarPoint(
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 0)
            );
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            intersectPoint = new THREE.Vector3();

            // Get camera element reference
            cameraEl = document.querySelector('a-camera');

            // Small delay to ensure everything is ready
            setTimeout(() => {
                sceneReady = true;
                loadSceneFromUrl();

                // If no scene was loaded from URL, check for saved scene in localStorage
                if (objects.length === 0) {
                    restoreSavedScene();
                }

                console.log('Scene ready for interaction');
            }, 500);
        });
    </script>
</body>

</html>